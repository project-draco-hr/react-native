{
  if (cls == ViewManager.class) {
    return EMPTY_PROPS_MAP;
  }
  Map<String,PropSetter> props=CLASS_PROPS_CACHE.get(cls);
  if (props != null) {
    return props;
  }
  props=new HashMap<>(getNativePropSettersForClass((Class<? extends ViewManager>)cls.getSuperclass()));
  for (  Method method : cls.getDeclaredMethods()) {
{
      ReactProp annotation=method.getAnnotation(ReactProp.class);
      if (annotation != null) {
        Class<?>[] paramTypes=method.getParameterTypes();
        if (paramTypes.length != 2) {
          throw new RuntimeException("Wrong number of args for prop setter: " + cls.getName() + "#"+ method.getName());
        }
        if (!View.class.isAssignableFrom(paramTypes[0])) {
          throw new RuntimeException("First param should be a view subclass to be updated: " + cls.getName() + "#"+ method.getName());
        }
        Class<?> propTypeClass=paramTypes[1];
        PropSetter propSetter;
        if (propTypeClass == boolean.class) {
          propSetter=new BooleanPropSetter(annotation,method,annotation.defaultBoolean());
        }
 else         if (propTypeClass == int.class) {
          propSetter=new IntPropSetter(annotation,method,annotation.defaultInt());
        }
 else         if (propTypeClass == float.class) {
          propSetter=new FloatPropSetter(annotation,method,annotation.defaultFloat());
        }
 else         if (propTypeClass == double.class) {
          propSetter=new DoublePropSetter(annotation,method,annotation.defaultDouble());
        }
 else         if (propTypeClass == String.class) {
          propSetter=new StringPropSetter(annotation,method);
        }
 else         if (propTypeClass == Boolean.class) {
          propSetter=new BoxedBooleanPropSetter(annotation,method);
        }
 else         if (propTypeClass == Integer.class) {
          propSetter=new BoxedIntPropSetter(annotation,method);
        }
 else         if (propTypeClass == ReadableArray.class) {
          propSetter=new ArrayPropSetter(annotation,method);
        }
 else         if (propTypeClass == ReadableMap.class) {
          propSetter=new MapPropSetter(annotation,method);
        }
 else {
          throw new RuntimeException("Unrecognized type");
        }
        props.put(annotation.name(),propSetter);
      }
    }
{
      ReactPropGroup annotation=method.getAnnotation(ReactPropGroup.class);
      if (annotation != null) {
        Class<?>[] paramTypes=method.getParameterTypes();
        if (paramTypes.length != 3) {
          throw new RuntimeException("Wrong number of args for group prop setter: " + cls.getName() + "#"+ method.getName());
        }
        if (!View.class.isAssignableFrom(paramTypes[0])) {
          throw new RuntimeException("First param should be a view subclass to be updated: " + cls.getName() + "#"+ method.getName());
        }
        if (paramTypes[1] != int.class) {
          throw new RuntimeException("Second argument should be property index: " + cls.getName() + "#"+ method.getName());
        }
        Class<?> propTypeClass=paramTypes[2];
        String[] names=annotation.names();
        if (propTypeClass == int.class) {
          for (int i=0; i < names.length; i++) {
            props.put(names[i],new GroupIntSetter(annotation,method,i,annotation.defaultInt()));
          }
        }
 else         if (propTypeClass == float.class) {
          for (int i=0; i < names.length; i++) {
            props.put(names[i],new GroupFloatSetter(annotation,method,i,annotation.defaultFloat()));
          }
        }
 else         if (propTypeClass == Integer.class) {
          for (int i=0; i < names.length; i++) {
            props.put(names[i],new GroupBoxedIntSetter(annotation,method,i));
          }
        }
 else {
          throw new RuntimeException("Unrecognized type: " + paramTypes[2] + " for method: "+ cls.getName()+ "#"+ method.getName());
        }
      }
    }
  }
  CLASS_PROPS_CACHE.put(cls,props);
  return props;
}
