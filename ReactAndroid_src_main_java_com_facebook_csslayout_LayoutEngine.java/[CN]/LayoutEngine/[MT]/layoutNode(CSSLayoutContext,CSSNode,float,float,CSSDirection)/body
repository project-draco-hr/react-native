{
  layoutContext.currentGenerationCount++;
  if (Float.isNaN(availableWidth) && node.style.dimensions[DIMENSION_WIDTH] >= 0.0) {
    float marginAxisRow=(node.style.margin.getWithFallback(leadingSpacing[CSS_FLEX_DIRECTION_ROW],leading[CSS_FLEX_DIRECTION_ROW]) + node.style.margin.getWithFallback(trailingSpacing[CSS_FLEX_DIRECTION_ROW],trailing[CSS_FLEX_DIRECTION_ROW]));
    availableWidth=node.style.dimensions[DIMENSION_WIDTH] + marginAxisRow;
  }
  if (Float.isNaN(availableHeight) && node.style.dimensions[DIMENSION_HEIGHT] >= 0.0) {
    float marginAxisColumn=(node.style.margin.getWithFallback(leadingSpacing[CSS_FLEX_DIRECTION_COLUMN],leading[CSS_FLEX_DIRECTION_COLUMN]) + node.style.margin.getWithFallback(trailingSpacing[CSS_FLEX_DIRECTION_COLUMN],trailing[CSS_FLEX_DIRECTION_COLUMN]));
    availableHeight=node.style.dimensions[DIMENSION_HEIGHT] + marginAxisColumn;
  }
  CSSMeasureMode widthMeasureMode=Float.isNaN(availableWidth) ? CSSMeasureMode.UNDEFINED : CSSMeasureMode.EXACTLY;
  CSSMeasureMode heightMeasureMode=Float.isNaN(availableHeight) ? CSSMeasureMode.UNDEFINED : CSSMeasureMode.EXACTLY;
  if (layoutNodeInternal(layoutContext,node,availableWidth,availableHeight,parentDirection,widthMeasureMode,heightMeasureMode,true,"initial")) {
    setPosition(node,node.layout.direction);
  }
}
