{
  CSSDirection direction=resolveDirection(node,parentDirection);
  int mainAxis=resolveAxis(getFlexDirection(node),direction);
  int crossAxis=getCrossFlexDirection(mainAxis,direction);
  int resolvedRowAxis=resolveAxis(CSS_FLEX_DIRECTION_ROW,direction);
  setDimensionFromStyle(node,mainAxis);
  setDimensionFromStyle(node,crossAxis);
  node.layout.direction=direction;
  node.layout.position[leading[mainAxis]]+=node.style.margin.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis]) + getRelativePosition(node,mainAxis);
  node.layout.position[trailing[mainAxis]]+=node.style.margin.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis]) + getRelativePosition(node,mainAxis);
  node.layout.position[leading[crossAxis]]+=node.style.margin.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]) + getRelativePosition(node,crossAxis);
  node.layout.position[trailing[crossAxis]]+=node.style.margin.getWithFallback(trailingSpacing[crossAxis],trailing[crossAxis]) + getRelativePosition(node,crossAxis);
  int childCount=node.getChildCount();
  float paddingAndBorderAxisResolvedRow=((node.style.padding.getWithFallback(leadingSpacing[resolvedRowAxis],leading[resolvedRowAxis]) + node.style.border.getWithFallback(leadingSpacing[resolvedRowAxis],leading[resolvedRowAxis])) + (node.style.padding.getWithFallback(trailingSpacing[resolvedRowAxis],trailing[resolvedRowAxis]) + node.style.border.getWithFallback(trailingSpacing[resolvedRowAxis],trailing[resolvedRowAxis])));
  float paddingAndBorderAxisColumn=((node.style.padding.getWithFallback(leadingSpacing[CSS_FLEX_DIRECTION_COLUMN],leading[CSS_FLEX_DIRECTION_COLUMN]) + node.style.border.getWithFallback(leadingSpacing[CSS_FLEX_DIRECTION_COLUMN],leading[CSS_FLEX_DIRECTION_COLUMN])) + (node.style.padding.getWithFallback(trailingSpacing[CSS_FLEX_DIRECTION_COLUMN],trailing[CSS_FLEX_DIRECTION_COLUMN]) + node.style.border.getWithFallback(trailingSpacing[CSS_FLEX_DIRECTION_COLUMN],trailing[CSS_FLEX_DIRECTION_COLUMN])));
  if (isMeasureDefined(node)) {
    boolean isResolvedRowDimDefined=(!Float.isNaN(node.layout.dimensions[dim[resolvedRowAxis]]) && node.layout.dimensions[dim[resolvedRowAxis]] >= 0.0);
    float width=CSSConstants.UNDEFINED;
    CSSMeasureMode widthMode=CSSMeasureMode.UNDEFINED;
    if ((!Float.isNaN(node.style.dimensions[dim[resolvedRowAxis]]) && node.style.dimensions[dim[resolvedRowAxis]] >= 0.0)) {
      width=node.style.dimensions[DIMENSION_WIDTH];
      widthMode=CSSMeasureMode.EXACTLY;
    }
 else     if (isResolvedRowDimDefined) {
      width=node.layout.dimensions[dim[resolvedRowAxis]];
      widthMode=CSSMeasureMode.EXACTLY;
    }
 else {
      width=parentMaxWidth - (node.style.margin.getWithFallback(leadingSpacing[resolvedRowAxis],leading[resolvedRowAxis]) + node.style.margin.getWithFallback(trailingSpacing[resolvedRowAxis],trailing[resolvedRowAxis]));
      widthMode=CSSMeasureMode.AT_MOST;
    }
    width-=paddingAndBorderAxisResolvedRow;
    if (Float.isNaN(width)) {
      widthMode=CSSMeasureMode.UNDEFINED;
    }
    float height=CSSConstants.UNDEFINED;
    CSSMeasureMode heightMode=CSSMeasureMode.UNDEFINED;
    if ((!Float.isNaN(node.style.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]]) && node.style.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] >= 0.0)) {
      height=node.style.dimensions[DIMENSION_HEIGHT];
      heightMode=CSSMeasureMode.EXACTLY;
    }
 else     if ((!Float.isNaN(node.layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]]) && node.layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] >= 0.0)) {
      height=node.layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]];
      heightMode=CSSMeasureMode.EXACTLY;
    }
 else {
      height=parentMaxHeight - (node.style.margin.getWithFallback(leadingSpacing[resolvedRowAxis],leading[resolvedRowAxis]) + node.style.margin.getWithFallback(trailingSpacing[resolvedRowAxis],trailing[resolvedRowAxis]));
      heightMode=CSSMeasureMode.AT_MOST;
    }
    height-=((node.style.padding.getWithFallback(leadingSpacing[CSS_FLEX_DIRECTION_COLUMN],leading[CSS_FLEX_DIRECTION_COLUMN]) + node.style.border.getWithFallback(leadingSpacing[CSS_FLEX_DIRECTION_COLUMN],leading[CSS_FLEX_DIRECTION_COLUMN])) + (node.style.padding.getWithFallback(trailingSpacing[CSS_FLEX_DIRECTION_COLUMN],trailing[CSS_FLEX_DIRECTION_COLUMN]) + node.style.border.getWithFallback(trailingSpacing[CSS_FLEX_DIRECTION_COLUMN],trailing[CSS_FLEX_DIRECTION_COLUMN])));
    if (Float.isNaN(height)) {
      heightMode=CSSMeasureMode.UNDEFINED;
    }
    boolean isRowUndefined=!(!Float.isNaN(node.style.dimensions[dim[resolvedRowAxis]]) && node.style.dimensions[dim[resolvedRowAxis]] >= 0.0) && !isResolvedRowDimDefined;
    boolean isColumnUndefined=!(!Float.isNaN(node.style.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]]) && node.style.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] >= 0.0) && Float.isNaN(node.layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]]);
    if (isRowUndefined || isColumnUndefined) {
      MeasureOutput measureDim=node.measure(layoutContext.measureOutput,width,widthMode,height,heightMode);
      if (isRowUndefined) {
        node.layout.dimensions[DIMENSION_WIDTH]=measureDim.width + paddingAndBorderAxisResolvedRow;
      }
      if (isColumnUndefined) {
        node.layout.dimensions[DIMENSION_HEIGHT]=measureDim.height + paddingAndBorderAxisColumn;
      }
    }
    if (childCount == 0) {
      return;
    }
  }
  boolean isNodeFlexWrap=(node.style.flexWrap == CSSWrap.WRAP);
  CSSJustify justifyContent=node.style.justifyContent;
  float leadingPaddingAndBorderMain=(node.style.padding.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis]) + node.style.border.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis]));
  float leadingPaddingAndBorderCross=(node.style.padding.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]) + node.style.border.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]));
  float paddingAndBorderAxisMain=((node.style.padding.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis]) + node.style.border.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis])) + (node.style.padding.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis]) + node.style.border.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis])));
  float paddingAndBorderAxisCross=((node.style.padding.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]) + node.style.border.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis])) + (node.style.padding.getWithFallback(trailingSpacing[crossAxis],trailing[crossAxis]) + node.style.border.getWithFallback(trailingSpacing[crossAxis],trailing[crossAxis])));
  boolean isMainDimDefined=(!Float.isNaN(node.layout.dimensions[dim[mainAxis]]) && node.layout.dimensions[dim[mainAxis]] >= 0.0);
  boolean isCrossDimDefined=(!Float.isNaN(node.layout.dimensions[dim[crossAxis]]) && node.layout.dimensions[dim[crossAxis]] >= 0.0);
  boolean isMainRowDirection=(mainAxis == CSS_FLEX_DIRECTION_ROW || mainAxis == CSS_FLEX_DIRECTION_ROW_REVERSE);
  int i;
  int ii;
  CSSNode child;
  int axis;
  CSSNode firstAbsoluteChild=null;
  CSSNode currentAbsoluteChild=null;
  float definedMainDim=CSSConstants.UNDEFINED;
  if (isMainDimDefined) {
    definedMainDim=node.layout.dimensions[dim[mainAxis]] - paddingAndBorderAxisMain;
  }
  int startLine=0;
  int endLine=0;
  int alreadyComputedNextLayout=0;
  float linesCrossDim=0;
  float linesMainDim=0;
  int linesCount=0;
  while (endLine < childCount) {
    float mainContentDim=0;
    int flexibleChildrenCount=0;
    float totalFlexible=0;
    int nonFlexibleChildrenCount=0;
    boolean isSimpleStackMain=(isMainDimDefined && justifyContent == CSSJustify.FLEX_START) || (!isMainDimDefined && justifyContent != CSSJustify.CENTER);
    int firstComplexMain=(isSimpleStackMain ? childCount : startLine);
    boolean isSimpleStackCross=true;
    int firstComplexCross=childCount;
    CSSNode firstFlexChild=null;
    CSSNode currentFlexChild=null;
    float mainDim=leadingPaddingAndBorderMain;
    float crossDim=0;
    float maxWidth=CSSConstants.UNDEFINED;
    float maxHeight=CSSConstants.UNDEFINED;
    for (i=startLine; i < childCount; ++i) {
      child=node.getChildAt(i);
      child.lineIndex=linesCount;
      child.nextAbsoluteChild=null;
      child.nextFlexChild=null;
      CSSAlign alignItem=getAlignItem(node,child);
      if (alignItem == CSSAlign.STRETCH && child.style.positionType == CSSPositionType.RELATIVE && isCrossDimDefined && !(!Float.isNaN(child.style.dimensions[dim[crossAxis]]) && child.style.dimensions[dim[crossAxis]] >= 0.0)) {
        child.layout.dimensions[dim[crossAxis]]=Math.max(boundAxis(child,crossAxis,node.layout.dimensions[dim[crossAxis]] - paddingAndBorderAxisCross - (child.style.margin.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]) + child.style.margin.getWithFallback(trailingSpacing[crossAxis],trailing[crossAxis]))),((child.style.padding.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]) + child.style.border.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis])) + (child.style.padding.getWithFallback(trailingSpacing[crossAxis],trailing[crossAxis]) + child.style.border.getWithFallback(trailingSpacing[crossAxis],trailing[crossAxis]))));
      }
 else       if (child.style.positionType == CSSPositionType.ABSOLUTE) {
        if (firstAbsoluteChild == null) {
          firstAbsoluteChild=child;
        }
        if (currentAbsoluteChild != null) {
          currentAbsoluteChild.nextAbsoluteChild=child;
        }
        currentAbsoluteChild=child;
        for (ii=0; ii < 2; ii++) {
          axis=(ii != 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;
          if ((!Float.isNaN(node.layout.dimensions[dim[axis]]) && node.layout.dimensions[dim[axis]] >= 0.0) && !(!Float.isNaN(child.style.dimensions[dim[axis]]) && child.style.dimensions[dim[axis]] >= 0.0) && !Float.isNaN(child.style.position[leading[axis]])&& !Float.isNaN(child.style.position[trailing[axis]])) {
            child.layout.dimensions[dim[axis]]=Math.max(boundAxis(child,axis,node.layout.dimensions[dim[axis]] - ((node.style.padding.getWithFallback(leadingSpacing[axis],leading[axis]) + node.style.border.getWithFallback(leadingSpacing[axis],leading[axis])) + (node.style.padding.getWithFallback(trailingSpacing[axis],trailing[axis]) + node.style.border.getWithFallback(trailingSpacing[axis],trailing[axis]))) - (child.style.margin.getWithFallback(leadingSpacing[axis],leading[axis]) + child.style.margin.getWithFallback(trailingSpacing[axis],trailing[axis]))- (Float.isNaN(child.style.position[leading[axis]]) ? 0 : child.style.position[leading[axis]])- (Float.isNaN(child.style.position[trailing[axis]]) ? 0 : child.style.position[trailing[axis]])),((child.style.padding.getWithFallback(leadingSpacing[axis],leading[axis]) + child.style.border.getWithFallback(leadingSpacing[axis],leading[axis])) + (child.style.padding.getWithFallback(trailingSpacing[axis],trailing[axis]) + child.style.border.getWithFallback(trailingSpacing[axis],trailing[axis]))));
          }
        }
      }
      float nextContentDim=0;
      if (isMainDimDefined && (child.style.positionType == CSSPositionType.RELATIVE && child.style.flex > 0)) {
        flexibleChildrenCount++;
        totalFlexible+=child.style.flex;
        if (firstFlexChild == null) {
          firstFlexChild=child;
        }
        if (currentFlexChild != null) {
          currentFlexChild.nextFlexChild=child;
        }
        currentFlexChild=child;
        nextContentDim=((child.style.padding.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis]) + child.style.border.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis])) + (child.style.padding.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis]) + child.style.border.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis]))) + (child.style.margin.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis]) + child.style.margin.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis]));
      }
 else {
        maxWidth=CSSConstants.UNDEFINED;
        maxHeight=CSSConstants.UNDEFINED;
        if (!isMainRowDirection) {
          if ((!Float.isNaN(node.layout.dimensions[dim[resolvedRowAxis]]) && node.layout.dimensions[dim[resolvedRowAxis]] >= 0.0)) {
            maxWidth=node.layout.dimensions[dim[resolvedRowAxis]] - paddingAndBorderAxisResolvedRow;
          }
 else {
            maxWidth=parentMaxWidth - (node.style.margin.getWithFallback(leadingSpacing[resolvedRowAxis],leading[resolvedRowAxis]) + node.style.margin.getWithFallback(trailingSpacing[resolvedRowAxis],trailing[resolvedRowAxis])) - paddingAndBorderAxisResolvedRow;
          }
        }
 else {
          if ((!Float.isNaN(node.layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]]) && node.layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] >= 0.0)) {
            maxHeight=node.layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] - paddingAndBorderAxisColumn;
          }
 else {
            maxHeight=parentMaxHeight - (node.style.margin.getWithFallback(leadingSpacing[CSS_FLEX_DIRECTION_COLUMN],leading[CSS_FLEX_DIRECTION_COLUMN]) + node.style.margin.getWithFallback(trailingSpacing[CSS_FLEX_DIRECTION_COLUMN],trailing[CSS_FLEX_DIRECTION_COLUMN])) - paddingAndBorderAxisColumn;
          }
        }
        if (alreadyComputedNextLayout == 0) {
          layoutNode(layoutContext,child,maxWidth,maxHeight,direction);
        }
        if (child.style.positionType == CSSPositionType.RELATIVE) {
          nonFlexibleChildrenCount++;
          nextContentDim=(child.layout.dimensions[dim[mainAxis]] + child.style.margin.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis]) + child.style.margin.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis]));
        }
      }
      if (isNodeFlexWrap && isMainDimDefined && mainContentDim + nextContentDim > definedMainDim && i != startLine) {
        nonFlexibleChildrenCount--;
        alreadyComputedNextLayout=1;
        break;
      }
      if (isSimpleStackMain && (child.style.positionType != CSSPositionType.RELATIVE || (child.style.positionType == CSSPositionType.RELATIVE && child.style.flex > 0))) {
        isSimpleStackMain=false;
        firstComplexMain=i;
      }
      if (isSimpleStackCross && (child.style.positionType != CSSPositionType.RELATIVE || (alignItem != CSSAlign.STRETCH && alignItem != CSSAlign.FLEX_START) || (alignItem == CSSAlign.STRETCH && !isCrossDimDefined))) {
        isSimpleStackCross=false;
        firstComplexCross=i;
      }
      if (isSimpleStackMain) {
        child.layout.position[pos[mainAxis]]+=mainDim;
        if (isMainDimDefined) {
          child.layout.position[trailing[mainAxis]]=node.layout.dimensions[dim[mainAxis]] - child.layout.dimensions[dim[mainAxis]] - child.layout.position[pos[mainAxis]];
        }
        mainDim+=(child.layout.dimensions[dim[mainAxis]] + child.style.margin.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis]) + child.style.margin.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis]));
        crossDim=Math.max(crossDim,boundAxis(child,crossAxis,(child.layout.dimensions[dim[crossAxis]] + child.style.margin.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]) + child.style.margin.getWithFallback(trailingSpacing[crossAxis],trailing[crossAxis]))));
      }
      if (isSimpleStackCross) {
        child.layout.position[pos[crossAxis]]+=linesCrossDim + leadingPaddingAndBorderCross;
        if (isCrossDimDefined) {
          child.layout.position[trailing[crossAxis]]=node.layout.dimensions[dim[crossAxis]] - child.layout.dimensions[dim[crossAxis]] - child.layout.position[pos[crossAxis]];
        }
      }
      alreadyComputedNextLayout=0;
      mainContentDim+=nextContentDim;
      endLine=i + 1;
    }
    float leadingMainDim=0;
    float betweenMainDim=0;
    float remainingMainDim=0;
    if (isMainDimDefined) {
      remainingMainDim=definedMainDim - mainContentDim;
    }
 else {
      remainingMainDim=Math.max(mainContentDim,0) - mainContentDim;
    }
    if (flexibleChildrenCount != 0) {
      float flexibleMainDim=remainingMainDim / totalFlexible;
      float baseMainDim;
      float boundMainDim;
      currentFlexChild=firstFlexChild;
      while (currentFlexChild != null) {
        baseMainDim=flexibleMainDim * currentFlexChild.style.flex + ((currentFlexChild.style.padding.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis]) + currentFlexChild.style.border.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis])) + (currentFlexChild.style.padding.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis]) + currentFlexChild.style.border.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis])));
        boundMainDim=boundAxis(currentFlexChild,mainAxis,baseMainDim);
        if (baseMainDim != boundMainDim) {
          remainingMainDim-=boundMainDim;
          totalFlexible-=currentFlexChild.style.flex;
        }
        currentFlexChild=currentFlexChild.nextFlexChild;
      }
      flexibleMainDim=remainingMainDim / totalFlexible;
      if (flexibleMainDim < 0) {
        flexibleMainDim=0;
      }
      currentFlexChild=firstFlexChild;
      while (currentFlexChild != null) {
        currentFlexChild.layout.dimensions[dim[mainAxis]]=boundAxis(currentFlexChild,mainAxis,flexibleMainDim * currentFlexChild.style.flex + ((currentFlexChild.style.padding.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis]) + currentFlexChild.style.border.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis])) + (currentFlexChild.style.padding.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis]) + currentFlexChild.style.border.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis]))));
        maxWidth=CSSConstants.UNDEFINED;
        if ((!Float.isNaN(node.layout.dimensions[dim[resolvedRowAxis]]) && node.layout.dimensions[dim[resolvedRowAxis]] >= 0.0)) {
          maxWidth=node.layout.dimensions[dim[resolvedRowAxis]] - paddingAndBorderAxisResolvedRow;
        }
 else         if (!isMainRowDirection) {
          maxWidth=parentMaxWidth - (node.style.margin.getWithFallback(leadingSpacing[resolvedRowAxis],leading[resolvedRowAxis]) + node.style.margin.getWithFallback(trailingSpacing[resolvedRowAxis],trailing[resolvedRowAxis])) - paddingAndBorderAxisResolvedRow;
        }
        maxHeight=CSSConstants.UNDEFINED;
        if ((!Float.isNaN(node.layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]]) && node.layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] >= 0.0)) {
          maxHeight=node.layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] - paddingAndBorderAxisColumn;
        }
 else         if (isMainRowDirection) {
          maxHeight=parentMaxHeight - (node.style.margin.getWithFallback(leadingSpacing[CSS_FLEX_DIRECTION_COLUMN],leading[CSS_FLEX_DIRECTION_COLUMN]) + node.style.margin.getWithFallback(trailingSpacing[CSS_FLEX_DIRECTION_COLUMN],trailing[CSS_FLEX_DIRECTION_COLUMN])) - paddingAndBorderAxisColumn;
        }
        layoutNode(layoutContext,currentFlexChild,maxWidth,maxHeight,direction);
        child=currentFlexChild;
        currentFlexChild=currentFlexChild.nextFlexChild;
        child.nextFlexChild=null;
      }
    }
 else     if (justifyContent != CSSJustify.FLEX_START) {
      if (justifyContent == CSSJustify.CENTER) {
        leadingMainDim=remainingMainDim / 2;
      }
 else       if (justifyContent == CSSJustify.FLEX_END) {
        leadingMainDim=remainingMainDim;
      }
 else       if (justifyContent == CSSJustify.SPACE_BETWEEN) {
        remainingMainDim=Math.max(remainingMainDim,0);
        if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 != 0) {
          betweenMainDim=remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount - 1);
        }
 else {
          betweenMainDim=0;
        }
      }
 else       if (justifyContent == CSSJustify.SPACE_AROUND) {
        betweenMainDim=remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount);
        leadingMainDim=betweenMainDim / 2;
      }
    }
    mainDim+=leadingMainDim;
    for (i=firstComplexMain; i < endLine; ++i) {
      child=node.getChildAt(i);
      if (child.style.positionType == CSSPositionType.ABSOLUTE && !Float.isNaN(child.style.position[leading[mainAxis]])) {
        child.layout.position[pos[mainAxis]]=(Float.isNaN(child.style.position[leading[mainAxis]]) ? 0 : child.style.position[leading[mainAxis]]) + node.style.border.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis]) + child.style.margin.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis]);
      }
 else {
        child.layout.position[pos[mainAxis]]+=mainDim;
        if (isMainDimDefined) {
          child.layout.position[trailing[mainAxis]]=node.layout.dimensions[dim[mainAxis]] - child.layout.dimensions[dim[mainAxis]] - child.layout.position[pos[mainAxis]];
        }
        if (child.style.positionType == CSSPositionType.RELATIVE) {
          mainDim+=betweenMainDim + (child.layout.dimensions[dim[mainAxis]] + child.style.margin.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis]) + child.style.margin.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis]));
          crossDim=Math.max(crossDim,boundAxis(child,crossAxis,(child.layout.dimensions[dim[crossAxis]] + child.style.margin.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]) + child.style.margin.getWithFallback(trailingSpacing[crossAxis],trailing[crossAxis]))));
        }
      }
    }
    float containerCrossAxis=node.layout.dimensions[dim[crossAxis]];
    if (!isCrossDimDefined) {
      containerCrossAxis=Math.max(boundAxis(node,crossAxis,crossDim + paddingAndBorderAxisCross),paddingAndBorderAxisCross);
    }
    for (i=firstComplexCross; i < endLine; ++i) {
      child=node.getChildAt(i);
      if (child.style.positionType == CSSPositionType.ABSOLUTE && !Float.isNaN(child.style.position[leading[crossAxis]])) {
        child.layout.position[pos[crossAxis]]=(Float.isNaN(child.style.position[leading[crossAxis]]) ? 0 : child.style.position[leading[crossAxis]]) + node.style.border.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]) + child.style.margin.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]);
      }
 else {
        float leadingCrossDim=leadingPaddingAndBorderCross;
        if (child.style.positionType == CSSPositionType.RELATIVE) {
          CSSAlign alignItem=getAlignItem(node,child);
          if (alignItem == CSSAlign.STRETCH) {
            if (!(!Float.isNaN(child.style.dimensions[dim[crossAxis]]) && child.style.dimensions[dim[crossAxis]] >= 0.0)) {
              float dimCrossAxis=child.layout.dimensions[dim[crossAxis]];
              child.layout.dimensions[dim[crossAxis]]=Math.max(boundAxis(child,crossAxis,containerCrossAxis - paddingAndBorderAxisCross - (child.style.margin.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]) + child.style.margin.getWithFallback(trailingSpacing[crossAxis],trailing[crossAxis]))),((child.style.padding.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]) + child.style.border.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis])) + (child.style.padding.getWithFallback(trailingSpacing[crossAxis],trailing[crossAxis]) + child.style.border.getWithFallback(trailingSpacing[crossAxis],trailing[crossAxis]))));
              if (dimCrossAxis != child.layout.dimensions[dim[crossAxis]] && child.getChildCount() > 0) {
                child.layout.position[leading[mainAxis]]-=child.style.margin.getWithFallback(leadingSpacing[mainAxis],leading[mainAxis]) + getRelativePosition(child,mainAxis);
                child.layout.position[trailing[mainAxis]]-=child.style.margin.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis]) + getRelativePosition(child,mainAxis);
                child.layout.position[leading[crossAxis]]-=child.style.margin.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]) + getRelativePosition(child,crossAxis);
                child.layout.position[trailing[crossAxis]]-=child.style.margin.getWithFallback(trailingSpacing[crossAxis],trailing[crossAxis]) + getRelativePosition(child,crossAxis);
                layoutNode(layoutContext,child,maxWidth,maxHeight,direction);
              }
            }
          }
 else           if (alignItem != CSSAlign.FLEX_START) {
            float remainingCrossDim=containerCrossAxis - paddingAndBorderAxisCross - (child.layout.dimensions[dim[crossAxis]] + child.style.margin.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]) + child.style.margin.getWithFallback(trailingSpacing[crossAxis],trailing[crossAxis]));
            if (alignItem == CSSAlign.CENTER) {
              leadingCrossDim+=remainingCrossDim / 2;
            }
 else {
              leadingCrossDim+=remainingCrossDim;
            }
          }
        }
        child.layout.position[pos[crossAxis]]+=linesCrossDim + leadingCrossDim;
        if (isCrossDimDefined) {
          child.layout.position[trailing[crossAxis]]=node.layout.dimensions[dim[crossAxis]] - child.layout.dimensions[dim[crossAxis]] - child.layout.position[pos[crossAxis]];
        }
      }
    }
    linesCrossDim+=crossDim;
    linesMainDim=Math.max(linesMainDim,mainDim);
    linesCount+=1;
    startLine=endLine;
  }
  if (linesCount > 1 && isCrossDimDefined) {
    float nodeCrossAxisInnerSize=node.layout.dimensions[dim[crossAxis]] - paddingAndBorderAxisCross;
    float remainingAlignContentDim=nodeCrossAxisInnerSize - linesCrossDim;
    float crossDimLead=0;
    float currentLead=leadingPaddingAndBorderCross;
    CSSAlign alignContent=node.style.alignContent;
    if (alignContent == CSSAlign.FLEX_END) {
      currentLead+=remainingAlignContentDim;
    }
 else     if (alignContent == CSSAlign.CENTER) {
      currentLead+=remainingAlignContentDim / 2;
    }
 else     if (alignContent == CSSAlign.STRETCH) {
      if (nodeCrossAxisInnerSize > linesCrossDim) {
        crossDimLead=(remainingAlignContentDim / linesCount);
      }
    }
    int endIndex=0;
    for (i=0; i < linesCount; ++i) {
      int startIndex=endIndex;
      float lineHeight=0;
      for (ii=startIndex; ii < childCount; ++ii) {
        child=node.getChildAt(ii);
        if (child.style.positionType != CSSPositionType.RELATIVE) {
          continue;
        }
        if (child.lineIndex != i) {
          break;
        }
        if ((!Float.isNaN(child.layout.dimensions[dim[crossAxis]]) && child.layout.dimensions[dim[crossAxis]] >= 0.0)) {
          lineHeight=Math.max(lineHeight,child.layout.dimensions[dim[crossAxis]] + (child.style.margin.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]) + child.style.margin.getWithFallback(trailingSpacing[crossAxis],trailing[crossAxis])));
        }
      }
      endIndex=ii;
      lineHeight+=crossDimLead;
      for (ii=startIndex; ii < endIndex; ++ii) {
        child=node.getChildAt(ii);
        if (child.style.positionType != CSSPositionType.RELATIVE) {
          continue;
        }
        CSSAlign alignContentAlignItem=getAlignItem(node,child);
        if (alignContentAlignItem == CSSAlign.FLEX_START) {
          child.layout.position[pos[crossAxis]]=currentLead + child.style.margin.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]);
        }
 else         if (alignContentAlignItem == CSSAlign.FLEX_END) {
          child.layout.position[pos[crossAxis]]=currentLead + lineHeight - child.style.margin.getWithFallback(trailingSpacing[crossAxis],trailing[crossAxis]) - child.layout.dimensions[dim[crossAxis]];
        }
 else         if (alignContentAlignItem == CSSAlign.CENTER) {
          float childHeight=child.layout.dimensions[dim[crossAxis]];
          child.layout.position[pos[crossAxis]]=currentLead + (lineHeight - childHeight) / 2;
        }
 else         if (alignContentAlignItem == CSSAlign.STRETCH) {
          child.layout.position[pos[crossAxis]]=currentLead + child.style.margin.getWithFallback(leadingSpacing[crossAxis],leading[crossAxis]);
        }
      }
      currentLead+=lineHeight;
    }
  }
  boolean needsMainTrailingPos=false;
  boolean needsCrossTrailingPos=false;
  if (!isMainDimDefined) {
    node.layout.dimensions[dim[mainAxis]]=Math.max(boundAxis(node,mainAxis,linesMainDim + (node.style.padding.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis]) + node.style.border.getWithFallback(trailingSpacing[mainAxis],trailing[mainAxis]))),paddingAndBorderAxisMain);
    if (mainAxis == CSS_FLEX_DIRECTION_ROW_REVERSE || mainAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) {
      needsMainTrailingPos=true;
    }
  }
  if (!isCrossDimDefined) {
    node.layout.dimensions[dim[crossAxis]]=Math.max(boundAxis(node,crossAxis,linesCrossDim + paddingAndBorderAxisCross),paddingAndBorderAxisCross);
    if (crossAxis == CSS_FLEX_DIRECTION_ROW_REVERSE || crossAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) {
      needsCrossTrailingPos=true;
    }
  }
  if (needsMainTrailingPos || needsCrossTrailingPos) {
    for (i=0; i < childCount; ++i) {
      child=node.getChildAt(i);
      if (needsMainTrailingPos) {
        child.layout.position[trailing[mainAxis]]=node.layout.dimensions[dim[mainAxis]] - child.layout.dimensions[dim[mainAxis]] - child.layout.position[pos[mainAxis]];
      }
      if (needsCrossTrailingPos) {
        child.layout.position[trailing[crossAxis]]=node.layout.dimensions[dim[crossAxis]] - child.layout.dimensions[dim[crossAxis]] - child.layout.position[pos[crossAxis]];
      }
    }
  }
  currentAbsoluteChild=firstAbsoluteChild;
  while (currentAbsoluteChild != null) {
    for (ii=0; ii < 2; ii++) {
      axis=(ii != 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;
      if ((!Float.isNaN(node.layout.dimensions[dim[axis]]) && node.layout.dimensions[dim[axis]] >= 0.0) && !(!Float.isNaN(currentAbsoluteChild.style.dimensions[dim[axis]]) && currentAbsoluteChild.style.dimensions[dim[axis]] >= 0.0) && !Float.isNaN(currentAbsoluteChild.style.position[leading[axis]])&& !Float.isNaN(currentAbsoluteChild.style.position[trailing[axis]])) {
        currentAbsoluteChild.layout.dimensions[dim[axis]]=Math.max(boundAxis(currentAbsoluteChild,axis,node.layout.dimensions[dim[axis]] - (node.style.border.getWithFallback(leadingSpacing[axis],leading[axis]) + node.style.border.getWithFallback(trailingSpacing[axis],trailing[axis])) - (currentAbsoluteChild.style.margin.getWithFallback(leadingSpacing[axis],leading[axis]) + currentAbsoluteChild.style.margin.getWithFallback(trailingSpacing[axis],trailing[axis]))- (Float.isNaN(currentAbsoluteChild.style.position[leading[axis]]) ? 0 : currentAbsoluteChild.style.position[leading[axis]])- (Float.isNaN(currentAbsoluteChild.style.position[trailing[axis]]) ? 0 : currentAbsoluteChild.style.position[trailing[axis]])),((currentAbsoluteChild.style.padding.getWithFallback(leadingSpacing[axis],leading[axis]) + currentAbsoluteChild.style.border.getWithFallback(leadingSpacing[axis],leading[axis])) + (currentAbsoluteChild.style.padding.getWithFallback(trailingSpacing[axis],trailing[axis]) + currentAbsoluteChild.style.border.getWithFallback(trailingSpacing[axis],trailing[axis]))));
      }
      if (!Float.isNaN(currentAbsoluteChild.style.position[trailing[axis]]) && !!Float.isNaN(currentAbsoluteChild.style.position[leading[axis]])) {
        currentAbsoluteChild.layout.position[leading[axis]]=node.layout.dimensions[dim[axis]] - currentAbsoluteChild.layout.dimensions[dim[axis]] - (Float.isNaN(currentAbsoluteChild.style.position[trailing[axis]]) ? 0 : currentAbsoluteChild.style.position[trailing[axis]]);
      }
    }
    child=currentAbsoluteChild;
    currentAbsoluteChild=currentAbsoluteChild.nextAbsoluteChild;
    child.nextAbsoluteChild=null;
  }
}
