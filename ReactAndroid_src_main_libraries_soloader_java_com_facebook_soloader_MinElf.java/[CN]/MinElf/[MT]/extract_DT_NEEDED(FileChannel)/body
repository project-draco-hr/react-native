{
  ByteBuffer bb=ByteBuffer.allocate(8);
  bb.order(ByteOrder.LITTLE_ENDIAN);
  if (getu32(fc,bb,Elf32_Ehdr.e_ident) != ELF_MAGIC) {
    throw new ElfError("file is not ELF");
  }
  boolean is32=(getu8(fc,bb,Elf32_Ehdr.e_ident + 0x4) == 1);
  if (getu8(fc,bb,Elf32_Ehdr.e_ident + 0x5) == 2) {
    bb.order(ByteOrder.BIG_ENDIAN);
  }
  long e_phoff=is32 ? getu32(fc,bb,Elf32_Ehdr.e_phoff) : get64(fc,bb,Elf64_Ehdr.e_phoff);
  long e_phnum=is32 ? getu16(fc,bb,Elf32_Ehdr.e_phnum) : getu16(fc,bb,Elf64_Ehdr.e_phnum);
  int e_phentsize=is32 ? getu16(fc,bb,Elf32_Ehdr.e_phentsize) : getu16(fc,bb,Elf64_Ehdr.e_phentsize);
  if (e_phnum == PN_XNUM) {
    long e_shoff=is32 ? getu32(fc,bb,Elf32_Ehdr.e_shoff) : get64(fc,bb,Elf64_Ehdr.e_shoff);
    long sh_info=is32 ? getu32(fc,bb,e_shoff + Elf32_Shdr.sh_info) : getu32(fc,bb,e_shoff + Elf64_Shdr.sh_info);
    e_phnum=sh_info;
  }
  long dynStart=0;
  long phdr=e_phoff;
  for (long i=0; i < e_phnum; ++i) {
    long p_type=is32 ? getu32(fc,bb,phdr + Elf32_Phdr.p_type) : getu32(fc,bb,phdr + Elf64_Phdr.p_type);
    if (p_type == PT_DYNAMIC) {
      long p_offset=is32 ? getu32(fc,bb,phdr + Elf32_Phdr.p_offset) : get64(fc,bb,phdr + Elf64_Phdr.p_offset);
      dynStart=p_offset;
      break;
    }
    phdr+=e_phentsize;
  }
  if (dynStart == 0) {
    throw new ElfError("ELF file does not contain dynamic linking information");
  }
  long d_tag;
  int nr_DT_NEEDED=0;
  long dyn=dynStart;
  long ptr_DT_STRTAB=0;
  do {
    d_tag=is32 ? getu32(fc,bb,dyn + Elf32_Dyn.d_tag) : get64(fc,bb,dyn + Elf64_Dyn.d_tag);
    if (d_tag == DT_NEEDED) {
      if (nr_DT_NEEDED == Integer.MAX_VALUE) {
        throw new ElfError("malformed DT_NEEDED section");
      }
      nr_DT_NEEDED+=1;
    }
 else     if (d_tag == DT_STRTAB) {
      ptr_DT_STRTAB=is32 ? getu32(fc,bb,dyn + Elf32_Dyn.d_un) : get64(fc,bb,dyn + Elf64_Dyn.d_un);
    }
    dyn+=is32 ? 8 : 16;
  }
 while (d_tag != DT_NULL);
  if (ptr_DT_STRTAB == 0) {
    throw new ElfError("Dynamic section string-table not found");
  }
  long off_DT_STRTAB=0;
  phdr=e_phoff;
  for (int i=0; i < e_phnum; ++i) {
    long p_type=is32 ? getu32(fc,bb,phdr + Elf32_Phdr.p_type) : getu32(fc,bb,phdr + Elf64_Phdr.p_type);
    if (p_type == PT_LOAD) {
      long p_vaddr=is32 ? getu32(fc,bb,phdr + Elf32_Phdr.p_vaddr) : get64(fc,bb,phdr + Elf64_Phdr.p_vaddr);
      long p_memsz=is32 ? getu32(fc,bb,phdr + Elf32_Phdr.p_memsz) : get64(fc,bb,phdr + Elf64_Phdr.p_memsz);
      if (p_vaddr <= ptr_DT_STRTAB && ptr_DT_STRTAB < p_vaddr + p_memsz) {
        long p_offset=is32 ? getu32(fc,bb,phdr + Elf32_Phdr.p_offset) : get64(fc,bb,phdr + Elf64_Phdr.p_offset);
        off_DT_STRTAB=p_offset + (ptr_DT_STRTAB - p_vaddr);
        break;
      }
    }
    phdr+=e_phentsize;
  }
  if (off_DT_STRTAB == 0) {
    throw new ElfError("did not find file offset of DT_STRTAB table");
  }
  String[] needed=new String[nr_DT_NEEDED];
  nr_DT_NEEDED=0;
  dyn=dynStart;
  do {
    d_tag=is32 ? getu32(fc,bb,dyn + Elf32_Dyn.d_tag) : get64(fc,bb,dyn + Elf64_Dyn.d_tag);
    if (d_tag == DT_NEEDED) {
      long d_val=is32 ? getu32(fc,bb,dyn + Elf32_Dyn.d_un) : get64(fc,bb,dyn + Elf64_Dyn.d_un);
      needed[nr_DT_NEEDED]=getSz(fc,bb,off_DT_STRTAB + d_val);
      if (nr_DT_NEEDED == Integer.MAX_VALUE) {
        throw new ElfError("malformed DT_NEEDED section");
      }
      nr_DT_NEEDED+=1;
    }
    dyn+=is32 ? 8 : 16;
  }
 while (d_tag != DT_NULL);
  if (nr_DT_NEEDED != needed.length) {
    throw new ElfError("malformed DT_NEEDED section");
  }
  return needed;
}
