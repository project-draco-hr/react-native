{
  if (keys.size() == 0) {
    callback.invoke(AsyncStorageErrorUtil.getInvalidKeyError(null));
    return;
  }
  new GuardedAsyncTask<Void,Void>(getReactApplicationContext()){
    @Override protected void doInBackgroundGuarded(    Void... params){
      if (!ensureDatabase()) {
        callback.invoke(AsyncStorageErrorUtil.getDBError(null));
        return;
      }
      mReactDatabaseSupplier.get().beginTransaction();
      try {
        for (int keyStart=0; keyStart < keys.size(); keyStart+=MAX_SQL_KEYS) {
          int keyCount=Math.min(keys.size() - keyStart,MAX_SQL_KEYS);
          mReactDatabaseSupplier.get().delete(TABLE_CATALYST,AsyncLocalStorageUtil.buildKeySelection(keyCount),AsyncLocalStorageUtil.buildKeySelectionArgs(keys,keyStart,keyCount));
        }
        mReactDatabaseSupplier.get().setTransactionSuccessful();
      }
 catch (      Exception e) {
        FLog.w(ReactConstants.TAG,"Exception in database multiRemove ",e);
        callback.invoke(AsyncStorageErrorUtil.getError(null,e.getMessage()));
      }
 finally {
        mReactDatabaseSupplier.get().endTransaction();
      }
      callback.invoke();
    }
  }
.execute();
}
