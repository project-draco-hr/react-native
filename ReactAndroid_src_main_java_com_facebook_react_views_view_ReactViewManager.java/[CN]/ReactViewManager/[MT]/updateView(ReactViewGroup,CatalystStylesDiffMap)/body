{
  super.updateView(view,props);
  ReactClippingViewGroupHelper.applyRemoveClippedSubviewsProperty(view,props);
  for (int i=0; i < SPACING_TYPES.length; i++) {
    String key=ViewProps.BORDER_WIDTHS[i];
    if (props.hasKey(key)) {
      float width=props.getFloat(key,CSSConstants.UNDEFINED);
      if (!CSSConstants.isUndefined(width)) {
        width=PixelUtil.toPixelFromDIP(width);
      }
      view.setBorderWidth(SPACING_TYPES[i],width);
    }
  }
  for (int i=0; i < SPACING_TYPES.length; i++) {
    String key=PROPS_BORDER_COLOR[i];
    if (props.hasKey(key)) {
      String color=props.getString(key);
      float colorFloat=color == null ? CSSConstants.UNDEFINED : CSSColorUtil.getColor(color);
      view.setBorderColor(SPACING_TYPES[i],colorFloat);
    }
  }
  if (props.hasKey(PROP_BORDER_RADIUS)) {
    view.setBorderRadius(PixelUtil.toPixelFromDIP(props.getFloat(PROP_BORDER_RADIUS,0.0f)));
  }
  if (props.hasKey(PROP_BORDER_STYLE)) {
    view.setBorderStyle(props.getString(PROP_BORDER_STYLE));
  }
  if (props.hasKey(PROP_POINTER_EVENTS)) {
    String pointerEventsStr=props.getString(PROP_POINTER_EVENTS);
    if (pointerEventsStr != null) {
      PointerEvents pointerEvents=PointerEvents.valueOf(pointerEventsStr.toUpperCase(Locale.US).replace("-","_"));
      view.setPointerEvents(pointerEvents);
    }
  }
  if (props.hasKey(PROP_NATIVE_BG)) {
    ReadableMap map=props.getMap(PROP_NATIVE_BG);
    view.setTranslucentBackgroundDrawable(map == null ? null : ReactDrawableHelper.createDrawableFromJSDescription(view.getContext(),map));
  }
  if (props.hasKey(PROP_ACCESSIBLE)) {
    view.setFocusable(props.getBoolean(PROP_ACCESSIBLE,false));
  }
  if (props.hasKey(ViewProps.NEEDS_OFFSCREEN_ALPHA_COMPOSITING)) {
    view.setNeedsOffscreenAlphaCompositing(props.getBoolean(ViewProps.NEEDS_OFFSCREEN_ALPHA_COMPOSITING,false));
  }
}
